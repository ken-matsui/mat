options {
	STATIC = false;
	DEBUG_PARSER = true;
	UNICODE_INPUT = true;
}

PARSER_BEGIN(Parser)

package mat.parser;

import mat.exception.*;
import java.lang.reflect.*;
import java.util.*;
import java.io.*;

class Parser {
	private String sourceName;
	private Set<String> knownTypedefs;

	public Parser(Reader s, String name, boolean debug) {
		this(s);
		this.sourceName = name;
		this.knownTypedefs = new HashSet<String>();
		if (debug) {
			enable_tracing();
		} else {
			disable_tracing();
		}
	}

	public void parse() throws SyntaxException {
		try {
			compilation_unit();
		} catch (TokenMgrError err) {
			throw new SyntaxException(err.getMessage());
		} catch (ParseException ex) {
			throw new SyntaxException(ex.getMessage());
		}
		//catch (LookaheadSuccess err) {
		//	throw new SyntaxException("syntax error");
		//}
	}

	static final public String SOURCE_ENCODING = "UTF-8";

	static public Parser newFileParser(File file, boolean debug)
									   throws FileException {
		try {
			BufferedReader r = new BufferedReader(
				new InputStreamReader(new FileInputStream(file), SOURCE_ENCODING)
			);
			return new Parser(r, file.getPath(), debug);
		} catch (FileNotFoundException ex) {
			throw new FileException(ex.getMessage());
		} catch (UnsupportedEncodingException ex) {
			throw new Error("UTF-8 is not supported?: " + ex.getMessage());
		}
	}

	static public void parseFile(File file, boolean debug)
								 throws SyntaxException, FileException {
		newFileParser(file, debug).parse();
	}

	static public void main(String[] srcs) {
		for (String src : srcs) {
			try {
				parseFile(new File(src), false);
			} catch (SyntaxException ex) {
				System.err.println(ex.getMessage());
			} catch (FileException ex) {
				System.err.println(ex.getMessage());
			}
		}
	}
}
PARSER_END(Parser)

//
// Skip tokens
//

// Ignore spaces
SKIP: { <SPACE: ([" ", "\t", "\r", "\n", "\f"])> }

// Keep two types of comments
SPECIAL_TOKEN: {
    <LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}
MORE: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMENT: "*/"> : DEFAULT }

//
// Tokens
//

// Reserved keywords
TOKEN: {
      <VOID     : "void">
    | <CHAR     : "char">
    | <SHORT    : "short">
    | <INT      : "int">
    | <LONG     : "long">
    | <STRUCT   : "struct">
    | <UNION    : "union">
    | <ENUM     : "enum">
    | <STATIC   : "static">
    | <EXTERN   : "extern">
    | <CONST    : "const">
    | <SIGNED   : "signed">
    | <UNSIGNED : "unsigned">
    | <IF       : "if">
    | <ELSE     : "else">
    | <SWITCH   : "switch">
    | <CASE     : "case">
    | <DEFAULT_ : "default">
    | <WHILE    : "while">
    | <DO       : "do">
    | <FOR      : "for">
    | <RETURN   : "return">
    | <BREAK    : "break">
    | <CONTINUE : "continue">
    | <TYPEDEF  : "typedef">
    | <IMPORT   : "import">
    | <SIZEOF   : "sizeof">
}

TOKEN: {
    <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}

TOKEN: {
    <INTEGER: ["1"-"9"] (["0"-"9"])* ("U")? ("L")?
            | "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
            | "0" (["0"-"7"])* ("U")? ("L")?
            >
}

// character literal
MORE: { <"'"> : IN_CHARACTER }                         // rule1
<IN_CHARACTER> MORE: {
      <~["'", "\\", "\n", "\r"]> : CHARACTER_TERM      // rule2
    | <"\\" (["0"-"7"]){3}>      : CHARACTER_TERM      // rule3
    | <"\\" ~[]>                 : CHARACTER_TERM      // rule4
}
<CHARACTER_TERM> TOKEN: { <CHARACTER: "'"> : DEFAULT } // rule5

// string literal
MORE: { <"\""> : IN_STRING }                           // rule1
<IN_STRING> MORE: {
      <(~["\"", "\\", "\n", "\r"])+>                   // rule2
    | <"\\" (["0"-"7"]){3}>                            // rule3
    | <"\\" ~[]>                                       // rule4
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }        // rule5

//
// Rules
//

String name():
{
	Token t;
}
{
	t=<IDENTIFIER> { return t.image; }
}

void compilation_unit(): {}
{
    import_stmts() expr2() <EOF>
}

void import_stmts(): {}
{
    (import_stmt())*
}

void import_stmt(): {}
{
	<IMPORT> name() ("." name())* ";"
}

long expr2():
{
	long l, r;
}
{
	l=expr1() ( "+" r=expr1() { l = l + r; }
	          | "-" r=expr1() { l = l - r; }
			  )*
			{
				return l;
			}
}

long expr1():
{
	long l, r;
}
{
	l=primary() ( "*" r=primary() { l = l * r; }
			    | "/" r=primary() { l = l / r; }
				| "%" r=primary() { l = l % r; }
			    )*
			{
				return l;
			}
}

long primary():
{
	Token t;
}
{
	t=<INTEGER>
		{
			return Long.parseLong(t.image);
		}
}
